

# This file was *autogenerated* from the file answer.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1337 = Integer(1337); _sage_const_0x1337 = Integer(0x1337); _sage_const_7331 = Integer(7331); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0)
from Crypto.Util.number import *
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from ecdsa import NIST256p
from ecdsa.ellipticcurve import PointJacobi

blksize = AES.block_size

curve = NIST256p.curve
G = NIST256p.generator
n = NIST256p.order

lines = open('../dist/output.txt', 'r').readlines()
for line in lines:
    exec(line.strip())

ids = [_sage_const_1337 , _sage_const_0x1337 , _sage_const_7331 ]

matele = []
for id in ids:
    matele += [id ** _sage_const_2 , id, _sage_const_1 ]
mat = Matrix(Zmod(n), _sage_const_3 , _sage_const_3 , matele)
matinv = mat ** (-_sage_const_1 )

shares = list(map(lambda P: PointJacobi(curve, P[_sage_const_0 ], P[_sage_const_1 ], _sage_const_1 ), [s1, s2, s3]))
secret_G = PointJacobi(curve, _sage_const_0 , _sage_const_1 , _sage_const_0 )
for i in range(_sage_const_3 ):
    secret_G += int(matinv[_sage_const_2 ,i].lift()) * shares[i]
key = long_to_bytes(int((secret_G).x()))[:blksize]

cipher = AES.new(key, AES.MODE_ECB)
plain = unpad(cipher.decrypt(bytes.fromhex(enc)), blksize)

print(plain)

